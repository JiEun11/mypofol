use('sample-mflix');


/**
 *  a selector  
 *  {k: {$op: v}}
 *     
 */

// ex01) name이 'Jon Snow'인 사용자
db.users.find({name: { $eq: 'Jon Snow' }});

// ex02) 비교 연산자(comparison operator) $eq는 생략 가능: key-value pairs literally match
//       {name: { $eq: 'Jon Snow' }} (o)
//       {name: { 'Jon Snow' }}      (x) js syntax error
//       {name: 'Jon Snow'}          (o)
db.users.find({ name: 'Jon Snow'});



/**
 *  multiple selectors I: key가 다른 경우
 *   
 *  {k1: {$op1: v1}} $(relation operator) {k2: {$op2: v2}}
 * 
 *  {{k1: {$op1: v1} } $and {k2: {$op2: v2}}}       (x) js syntax error
 *  {$and: [{ k1: {$op1: v1}}, {k2: {$op2: v2}}]}   (o)    
 */


// ex03) 1997년에 방영된 TV 씨리즈물

// 1. 두 개의 selector 필요: {type: {$eq: 'series'}} 와 {year: {$eq: 1997}}
// 2. $and selector: {$and : [{type: {$eq: 'series'}}, {year: {$eq: 1997}}]}
// 3. $and selector를 첫 번째 argument로 find 실행

db.movies.find({$and : [{type: {$eq: 'series'}}, {year: {$eq: 1997}}]})


// ex04) 생략 해보기I: $eq 생략
db.movies.find({$and : [{type: 'series'}, {year: 1997}]})


// ex05) 생략 해보기II: $and 생략
// $and와 함께 배열([])을 생략할 수 있다.  
//
// {$and : [{type: 'series'}, {year: 1997}]}
// {{type: 'series'}, {year: 1997}}         (x) js syntax error
// {type: 'series', year: 1997}             (o)
db.movies.find({type: 'series', year: 1997})





/**
 *  [정리]
 *  
 *  1. 대부분의 selector는 위와 같은 원리로 작성하면 된다.
 *  2. $eq, $and가 생략된 selector는 익숙한 js object 형태이지만 mongoDB selector들 중에는 operator가 생략된 아주 특별한 selector 이다.
 *  3. $eq, $and만 빼고 대부분의 selector 에서의 operator는 당연히 생략 할 수 없다.
 *  4. $eq, $and가 생략 가능하여 간단한 형태이기 때문제 입문 예제에 많이 사용하여 오히려 평범한 selector가 더 낯설어 보이게 한다.
 *  5. $eq, $and도 사실, 명시해야 하는 selector가 더 많다.
 * 
 */

// find는 cursor 객체를 리턴하지만 findOne은 Document를 리턴한다.
db.users.findOne({name: 'Jon Snow'});




